# 문제1
아래 두 테이블이 있습니다.
- order(order_id, customer_id, channel_id, order_dt, order_amt, status)
- customer(customer_id, gender, age, region)

최근 30일간 정상 주문(status='정상') 기준,
1회 이상 주문한 모든 고객에 대해
- 고객 ID,
- 전체 주문수(order_cnt),
- 총 주문액(total_amt),
- 주문간 평균 구매간격(일) (avg_gap_days)을 구하세요.

평균 구매간격:
- 고객별로 주문일을 오름차순 정렬
- 각 주문의 날짜 차이(일) 평균
(즉, [두 번째 주문일 - 첫 주문일], [세 번째 주문일 - 두 번째 주문일], … 등등의 평균)
- 주문이 1건뿐인 고객은 avg_gap_days는 NULL로 표시

출력 컬럼:
- customer_id
- order_cnt
- total_amt
- avg_gap_days

오라클 기준, order_cnt 내림차순, 그 안에서 customer_id 오름차순 정렬

# 내 풀이1
```
SELECT
  customer_id,
  COUNT(*) AS order_cnt,
  SUM(order_amt) AS total_amt,
  CASE
    WHEN COUNT(*) = 1 THEN NULL
    ELSE ROUND(AVG(gap_days))
  END AS avg_gap_days
FROM (
  SELECT
    o.customer_id,
    o.order_amt,
    trunc(o.order_dt) AS order_dt,
    trunc(o.order_dt) - LAG(trunc(o.order_dt)) OVER (PARTITION BY o.customer_id ORDER BY trunc(o.order_dt)) AS gap_days
  FROM
    order o
  WHERE
    o.status = '정상'
    AND trunc(o.order_dt) >= trunc(sysdate) - 29
)
GROUP BY customer_id
ORDER BY order_cnt DESC, customer_id
;
```

# 문제2
[테이블 설명]
patient
(patient_id, gender, birth_dt, region)
visit
(visit_id, patient_id, doctor_id, visit_dt, department, visit_type, total_cost, diagnosis_code)

최근 6개월간
**내과(Department='내과')**에서
만 40세 이상 환자의
환자별로
첫 방문일(first_visit_dt)
마지막 방문일(last_visit_dt)
전체 방문 수(visit_cnt)
총 진료비(total_cost_sum)
을 구하시오.

단, 첫 방문일과 마지막 방문일이 같은 환자(즉, 1회만 방문한 환자)는 결과에서 제외
visit_type은 "외래", "입원" 등 다양하나 모든 유형 포함
출력 컬럼: patient_id, first_visit_dt, last_visit_dt, visit_cnt, total_cost_sum
최근 6개월 기준: visit_dt >= ADD_MONTHS(TRUNC(SYSDATE), -6)
오라클 기준, 마지막 방문일 내림차순 정렬

# 내 풀이2
select
  p.patient_id,
  min(v.visit_dt) as first_visit_dt,
  max(v.visit_dt) as last_visit_dt,
  count(*) as visit_cnt,
  sum(v.total_cost) as total_cost_sum
from
  visit v
  inner join patient p on v.patient_id = p.patient_id
where
  v.department = '내과'
  and v.visit_dt >= add_months(trunc(sysdate), -6)
  and FLOOR(MONTHS_BETWEEN(TRUNC(SYSDATE), p.birth_dt) / 12) >= 40
group by
  p.patient_id
having
  count(*) > 1
order by
  last_visit_dt desc
;